\mode*
\label{cppjava}

We want to write a short class to work with fractions.
We want to do this twice, once for C++ and once for Java.

\begin{activity}
While reading the rest of this section,
try to write the same program and experiment with it.
\end{activity}

\subsection{Compiling the files}

We'll start with the makefile.
We'll write a file [[<<frac.mk>>]] to include from our [[Makefile]], this file 
keeps only the building rules for this particular section.
\begin{frame}[fragile]
<<frac.mk>>=
<<frac variable definitions>>

.PHONY: all
all: # to make it the first target in the file, if used as main file
<<more [[all]] targets to add depends>>

<<frac targets>>

.PHONY: clean
clean: clean-frac # since we already have a recipe for clean in Makefile
clean-frac:
	<<remove generated files>>
@
\end{frame}

\subsection{C++}

The class should be used as the following example programs show.
\begin{frame}[fragile]
<<fracexample.cpp>>=
#include <iostream>
#include "fraction.h"

int main() {
  Fraction f1(1, 2);
  Fraction f2(1, 3);
  std::cout << f1 << " + " << f2
            << " = " << (f1 + f2) << std::endl;
}
@

The expected output is:
\begin{pycode}
didactic_shell("./fracexample", minted_opts="numbers=none")
\end{pycode}
\end{frame}

To compile the [[fracexample]] program, we need its prerequisites.
We need the header file [[fraction.h]] and object file [[fraction.o]]---that 
provides the implementation of the class.
We also need the source file [[fracexample.cpp]].
\begin{frame}[fragile]
<<frac targets>>=
fracexample: fraction.o fracexample.cpp fraction.h
<<remove generated files>>=
rm -f fracexample
@ We want to use C++17.
To use the built-in rules of [[make]]\only<article>{\footnote{%
  Worth noting in this context: (GNU) [[make]] has built-in rules for Knuth's 
  original WEB system, the one discussed in \cite{Knuth1984}.
}}, we need to define the variables [[CXXFLAGS]] and [[LDFLAGS]] to have the 
options we need.
We want the usual [[-W]] flags to catch common errors.
<<frac variable definitions>>=
CXXFLAGS+=  -std=c++17 -Wall -Wextra -Werror ${DEBUGFLAGS}
LDFLAGS+=   -lstdc++
@ We also need to add the test program to the [[all]] target and the cleaning.
<<more [[all]] targets to add depends>>=
all: fracexample
@
\end{frame}

We also want to test the fraction class with the following test program.
The test program will use Google Test framework.
\begin{frame}[fragile]
<<fractest.cpp>>=
#include <gtest/gtest.h>
<<headers to include>>
#include "fraction.h"

<<tests for Fraction>>

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
@
\end{frame}

To compile the test program, we've already covered parts of its needs above.
We need the header file [[fraction.h]] and object file [[fraction.o]].
We also need the source file [[fractest.cpp]].
Now, [[fractest]] is a special case, the built-in rules will not work.
Here we need to link against the Google Test framework library.
So we need a custom build rule for this that includes [[-lgtest]] and 
[[lgtest_main]] so that the linker links against the Google Test framework.
(The alternative would be to add the Google Test framework to the [[LDFLAGS]], 
but then we would link all programs against it---undesirable.)
\begin{frame}[fragile]
<<frac targets>>=
fractest: fraction.o fractest.cpp fraction.h
	${CXX} ${CXXFLAGS} -o $@ $^ ${LDFLAGS} -lgtest -lgtest_main
@ We also need to add the test program to the [[all]] target and the cleaning.
<<more [[all]] targets to add depends>>=
all: fractest
<<remove generated files>>=
rm -f fractest
@
\end{frame}

\subsubsection{Tangling with the \texttt{-L} flag}

These targets above depend on the source files.
We need to build them from the \noweb{} source file.
\begin{frame}[fragile]
<<frac.mk>>=
fraction.cpp fraction.h fractest.cpp fracexample.cpp: cppjava.nw
	notangle -L -R$@ $< | cpif $@
	noroots $<
@ There are two things to note:
the [[-L]] flag and the [[noroots]] program.
\end{frame}

The [[noroots]] program simply lists all the root chunks of a \noweb{} source 
file.
We use this one to see that they all look like root chunks, that is files to be 
extracted.
\begin{frame}[fragile]
The output of [[noroots]] looks like this:
\begin{pycode}
didactic_shell("noroots cppjava.nw", shell=True, minted_opts="numbers=none")
\end{pycode}

\begin{activity}
When could the output of [[noroots]] ever be useful?
\end{activity}
\end{frame}

If we spell a chunks wrongly, it will not be used in the other code.
Then it will be considered a root chunk and we can use the output from 
[[noroots]] here to see that we've missed something.

In the output above, all roots look like files that we expect, so everything is 
fine\footnote{%
  In fact, when I first wrote this I had decided to have one [[cppfrac.mk]] 
  file for C++ and one [[javafrac.mk]] for Java.
  Later I decided to have one [[frac.mk]] file for both.
  However, I forgot to change the name of the chunk above, so it was still 
  named [[cppfrac.mk]].
  I could detect this with the help of [[noroots]].
}.

Now we'll turn our focus to the [[-L]] flag.
When we tangle the files, we want the [[-L]] flag.
The [[-L]] flag will rewrite the line numbers so that the compiler error 
messages will refer to the correct line in the \noweb{} source file, instead of 
the tangled file.
Without the [[-L]] flag, the tangled source will look as expected:
\begin{frame}[fragile]
\begin{pycode}
didactic_shell("notangle -Rfracexample.cpp cppjava.nw",
               shell=True, lang="cpp")
\end{pycode}
\end{frame}
\begin{frame}[fragile]
But if we use the [[-L]] flag, the tangled source will include the directives 
to rewrite line numbers:
\begin{pycode}
with open("fracexample.cpp", "r") as f:
  didactic_mint(f.read(), lang="cpp", hlgrep=["^#line"])
\end{pycode}
\end{frame}

If we look at the file [[cppjava.nw]] (the source file for this section), we 
can see this around line 39:
\begin{frame}[fragile]
\inputminted[firstline=36,lastline=48]{text}{cppjava.nw}
\end{frame}
That is, the contents of
[[<<fracexample.cpp>>]]
starts at line 39.

Let's introduce the file [[<<fracexample2.cpp>>]] and introduce an error in it.
It should have the same contents as [[<<fracexample.cpp>>]], but we also add an 
erroneous function definition.
\begin{frame}[fragile]
We intentionally spell [[int]] as [[inte]] to trigger a compilation error.
<<fracexample2.cpp>>=
<<fracexample.cpp>>

inte bad_return_type_func() {
  return 0;
}
@
\end{frame}

Let's have a look at the tangled file [[<<fracexample2.cpp>>]].
\begin{frame}[fragile]
\inputminted[highlightlines={1,12}]{cpp}{fracexample2.cpp}
\end{frame}
We note lines 1 and 12.
Line 1 maps to the same line in the original \noweb{} source, just the same as 
above.
But line 12 maps to line 199 in the original \noweb{} source.
That's because we introduced [[<<fracexample2.cpp>>]] that far down:
\inputminted[firstline=195,lastline=202]{text}{cppjava.nw}

Let's try to compile [[<<fracexample2.cpp>>]] and have a look at the error 
message from the compiler.
We'll compile with
\begin{frame}[fragile]
\begin{minted}[numbers=none]{bash}
g++ -g -std=c++17 -Wall -Wextra -Werror -o fracexample2 \
  fracexample2.cpp fraction.cpp
\end{minted}
The result is the following:
\begin{pycode}
didactic_shell("g++ -std=c++17 -Wall -Wextra -Werror -o fracexample2 "
               "fracexample2.cpp fraction.cpp "
               "2>&1",
               shell=True, minted_opts="numbers=none")
\end{pycode}
\end{frame}
Indeed, we note that the compiler's error refers to the file [[cppjava.nw]] on 
line 199, rather than the tangled file [[fracexample2.cpp]].
\only<article>{\input{gdb.tex}}

\begin{activity}
Tangle the files with and without the [[-L]] flag and compile them.
See how it affects compiler messages and the debugger.
\end{activity}

We also want to see that this works also for the tests.
We're going to add a test for a case that we intensionally \emph{don't} handle, 
namely having a zero denominator.
We would expect setting the denominator to zero to throw an exception.
<<tests for Fraction>>=
TEST(Fraction, ZeroDenominator) {
  EXPECT_THROW(Fraction f(1, 0), std::invalid_argument);
}
<<headers to include>>=
#include <stdexcept>
@

When we execute the tests, we'll get the following output:
\begin{pycode}
didactic_shell("./fractest",
               hlgrep=["cppjava.nw"],
               minted_opts="numbers=none")
\end{pycode}
Let's have a peek at the lines around line 279 in [[cppjava.nw]]:
\inputminted[firstline=273,lastline=283]{text}{cppjava.nw}


\subsubsection{The class}

The class [[Fraction]] should represent a fraction.
The class needs two private attributes, [[numerator]] and [[denominator]] to 
keep track of those values.
We saw above that the class should have a constructor that takes two integers 
and initializes the attributes.
We also want to overload the operator [[+]] to add two fractions.
Finally, we also want to print a fraction in the form 
[[numerator/denominator]]---shortened as much as possible.
This gives us the following header file:
\begin{frame}[fragile]
<<fraction.h>>=
<<headers to include>>

class Fraction {
  private:
    int numerator;
    int denominator;
  public:
    Fraction(int numerator, int denominator);

    <<methods for Fraction>>
    <<overloaded operators>>
};
@
\end{frame}

\subsubsection{Implementing the methods}

Now we need to implement the methods, we have [[to_string]] and
[[<<overloaded operators>>]] to implement.
That should be done in the file [[<<fraction.cpp>>]].
\begin{frame}[fragile]
<<fraction.cpp>>=
<<headers to include>>
#include "fraction.h"

<<implementation of methods for Fraction>>
<<implementation of overloaded operators>>
@

To compile this file, we need the following simple rule.
<<frac targets>>=
fraction.o: fraction.cpp fraction.h
<<remove generated files>>=
rm -f fraction.o
@
\end{frame}

\subsubsection{The constructor}

The constructor should initialize the attributes.
We'll also want it to shorten the fraction as much as possible.
But we'll return to that later.
\begin{frame}[fragile]
<<implementation of methods for Fraction>>=
Fraction::Fraction(int numerator, int denominator)
  : numerator(numerator), denominator(denominator)
{
  <<shorten [[numerator]] and [[denominator]]>>
}
@

Let's test this:
<<tests for Fraction>>=
TEST(Fraction, Constructor) {
  Fraction f2(2, 4);
  EXPECT_EQ(f2.to_string(), "1/2");
}
@
\end{frame}

\subsubsection{Shortening the fraction}

To shorten the fraction, we need to find the greatest common divisor of the 
numerator and the denominator.
We can then divide both by this number.

We can use the [[std::gcd]] function from the C++17 standard library.
It requires the header [[<numeric>]].
<<headers to include>>=
#include <numeric>
<<shorten [[numerator]] and [[denominator]]>>=
int gcd = std::gcd(numerator, denominator);
this->numerator /= gcd;
this->denominator /= gcd;
@

Let's test this:
<<tests for Fraction>>=
TEST(Fraction, AddShorten) {
  Fraction f7(2, 4);
  EXPECT_EQ(f7.to_string(), "1/2");
  Fraction f8(1, 2);
  Fraction f9 = f7 + f8;
  EXPECT_EQ(f9.to_string(), "1/1");
}
@

\subsubsection{Converting to string}

We want to be able to print a fraction.
We can do this by implementing a method [[to_string]].
\begin{frame}[fragile]
<<methods for Fraction>>=
std::string to_string() const;
<<implementation of methods for Fraction>>=
std::string Fraction::to_string() const {
  return std::to_string(numerator) + "/" + std::to_string(denominator);
}
<<headers to include>>=
#include <string>
@
\end{frame}

Let's test this method.
We'll test two things:
\begin{enumerate}
\item That the fraction is printed correctly.
\item That the fraction is shortened.
\end{enumerate}
<<tests for Fraction>>=
TEST(Fraction, ToString) {
  Fraction f(1, 2);
  EXPECT_EQ(f.to_string(), "1/2");
  Fraction f2(4, 2);
  EXPECT_EQ(f2.to_string(), "2/1");
}
@

Now we also want to use this one to overload the [[<<]] operator so that we can 
print fractions using [[std::cout]].
Note that we don't define it as part of the class, in
[[<<overloaded operators>>]], but only outside the class.
This is to be able to do the overloading and controlling both parameters.
As part of the class it implicitly gets the [[this]] parameter instead.
<<headers to include>>=
#include <iostream>
<<overloaded operators>>=
friend std::ostream& operator<<(std::ostream& os, const Fraction& f);
<<implementation of overloaded operators>>=
std::ostream& operator<<(std::ostream& os, const Fraction& f) {
  os << f.to_string();
  return os;
}
@


\subsubsection{Adding fractions}

Let's turn to the overloaded [[+]] operator.
Let's start with some tests to see what we want to achieve.
\begin{frame}[fragile]
<<tests for Fraction>>=
TEST(Fraction, Add) {
  Fraction f1(1, 2);
  Fraction f2(1, 3);
  Fraction f3 = f1 + f2;
  EXPECT_EQ(f3.to_string(), "5/6");

  Fraction f4(1, 3);
  Fraction f5(1, 3);
  Fraction f6 = f4 + f5;
  EXPECT_EQ(f6.to_string(), "2/3");
}
@
\end{frame}

To achieve this, we need the method named [[operator+]].
<<overloaded operators>>=
Fraction operator+(const Fraction& other) const;
@ We'll use a reference for [[other]], but make it [[const]] so that we can't 
change it.
We also add [[const]] to the method itself to indicate that it doesn't change 
the object ([[this]]).
\begin{frame}[fragile]
<<implementation of overloaded operators>>=
Fraction Fraction::operator+(const Fraction& other) const {
  <<add [[this]] and [[other]] into [[new_numerator]] and [[new_denominator]]>>
  return Fraction(new_numerator, new_denominator);
}
@ We don't need to do anything special to shorten the fraction here.
Because the constructor already does that when we create the new [[Fraction]] 
that is returned.
\end{frame}

To add two fractions, we need to find a common denominator.
We can then just add the numerators.
<<add [[this]] and [[other]] into [[new_numerator]] and [[new_denominator]]>>=
int new_numerator = numerator * other.denominator
                    + other.numerator * denominator;
int new_denominator = denominator * other.denominator;
@


\subsection{Java}

The class should have two fields, \texttt{numerator} and \texttt{denominator}, 
and a constructor that takes two integers and initializes the fields.

The class should also have a method \texttt{add} (as Java doesn't support 
operator overloading) that takes another fraction as an argument and returns a 
new fraction that is the sum of the two fractions.

Finally, the class should have a method \texttt{toString} that returns a string 
representation of the fraction in the form 
\texttt{numerator/denominator}---shortened as much as possible.

\begin{activity}
Based on the ideas from the C++ part, write the corresponding Java program.
\end{activity}

\begin{frame}[fragile]
\begin{activity}
Java doesn't support the line preprocessor directive as the C++ compiler and 
debugger do.
Consequently, we can't use the exact same approach as for C++.
Can we solve this in another, yet similar, way?
\end{activity}
\end{frame}

\mode<presentation>{\endinput}

\subsection{The \noweb{} source}

Let's have a look at the \noweb{} source file for this section, \cref{cppjava}.
\inputminted{text}{cppjava.nw}
