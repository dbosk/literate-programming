\mode*
\label{cppjava}

We want to write a short class to work with fractions.
We want to do this twice, once for C++ and once for Java.

\begin{activity}
While reading the rest of this section,
try to write the same program and experiment with it.
\end{activity}

\subsection{Compiling the files}

We'll start with the makefile.
We'll write a file [[<<frac.mk>>]] to include from our [[Makefile]], this file 
keeps only the building rules for this particular section.
<<frac.mk>>=
<<frac variable definitions>>

.PHONY: all
all: # to make it the first target in the file, if used as main file
<<more [[all]] targets to add depends>>

<<frac targets>>

.PHONY: clean
clean: clean-frac # since we already have a recipe for clean in Makefile
clean-frac:
	<<remove generated files>>
@

\subsection{C++}

The class should be used as the following example programs show.
<<fracexample.cpp>>=
#include <iostream>
#include "fraction.h"

int main() {
  Fraction f1(1, 2);
  Fraction f2(1, 3);
  std::cout << f1 << " + " << f2
            << " = " << (f1 + f2) << std::endl;
}
@

The expected output is:
\begin{pycode}
didactic_shell("./fracexample", minted_opts="numbers=none")
\end{pycode}

To compile the [[fracexample]] program, we need its prerequisites.
We need the header file [[fraction.h]] and object file [[fraction.o]]---that 
provides the implementation of the class.
We also need the source file [[fracexample.cpp]].
<<frac targets>>=
fracexample: fraction.o fracexample.cpp fraction.h
<<more [[all]] targets to add depends>>=
all: fracexample
<<remove generated files>>=
rm -f fracexample
@ We want to use C++17.
To use the built-in rules of [[make]]\footnote{%
  Worth noting in this context: (GNU) [[make]] has built-in rules for Knuth's 
  original WEB system, the one discussed in \cite{Knuth1984}.
}, we need to define the variables [[CXXFLAGS]] and [[LDFLAGS]] to have the 
options we need.
We want the usual [[-W]] flags to catch common errors.
<<frac variable definitions>>=
CXXFLAGS+=  -std=c++17 -Wall -Wextra -Werror ${DEBUGFLAGS}
LDFLAGS+=   -lstdc++
@ We also need to add the test program to the [[all]] target and the cleaning.

We also want to test the fraction class with the following test program.
The test program will use Google Test framework.
<<fractest.cpp>>=
#include <gtest/gtest.h>
<<headers to include>>
#include "fraction.h"

<<tests for Fraction>>

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
@

To compile the test program, we've already covered parts of its needs above.
We need the header file [[fraction.h]] and object file [[fraction.o]].
We also need the source file [[fractest.cpp]].
Now, [[fractest]] is a special case, the built-in rules will not work.
Here we need to link against the Google Test framework library.
So we need a custom build rule for this that includes [[-lgtest]] and 
[[lgtest_main]] so that the linker links against the Google Test framework.
(The alternative would be to add the Google Test framework to the [[LDFLAGS]], 
but then we would link all programs against it---undesirable.)
<<frac targets>>=
fractest: fraction.o fractest.cpp fraction.h
	${CXX} ${CXXFLAGS} -o $@ $^ ${LDFLAGS} -lgtest -lgtest_main
@ We also need to add the test program to the [[all]] target and the cleaning.
<<more [[all]] targets to add depends>>=
all: fractest
<<remove generated files>>=
rm -f fractest
@

\subsubsection{Tangling with the \texttt{-L} flag}

These targets above depend on the source files.
We need to build them from the \noweb{} source file.
<<frac.mk>>=
fraction.cpp fraction.h fractest.cpp fracexample.cpp: cppjava.nw
	notangle -L -R$@ $< | cpif $@
	noroots $<
@ There are two things to note:
the [[-L]] flag and the [[noroots]] program.

The [[noroots]] program simply lists all the root chunks of a \noweb{} source 
file.
We use this one to see that they all look like root chunks, that is files to be 
extracted.
The output of [[noroots]] looks like this:
\begin{pycode}
didactic_shell("noroots cppjava.nw", shell=True, minted_opts="numbers=none")
\end{pycode}

\begin{activity}
When could the output of [[noroots]] ever be useful?
\end{activity}

If we spell a chunks wrongly, it will not be used in the other code.
Then it will be considered a root chunk and we can use the output from 
[[noroots]] here to see that we've missed something.

In the output above, all roots look like files that we expect, so everything is 
fine\footnote{%
  In fact, when I first wrote this I had decided to have one [[cppfrac.mk]] 
  file for C++ and one [[javafrac.mk]] for Java.
  Later I decided to have one [[frac.mk]] file for both.
  However, I forgot to change the name of the chunk above, so it was still 
  named [[cppfrac.mk]].
  I could detect this with the help of [[noroots]].
}.

Now we'll turn our focus to the [[-L]] flag.
When we tangle the files, we want the [[-L]] flag.
The [[-L]] flag will rewrite the line numbers so that the compiler error 
messages will refer to the correct line in the \noweb{} source file, instead of 
the tangled file.
Without the [[-L]] flag, the tangled source will look as expected:
\begin{pycode}
didactic_shell("notangle -Rfracexample.cpp cppjava.nw",
               shell=True, lang="cpp")
\end{pycode}
But if we use the [[-L]] flag, the tangled source will include the directives 
to rewrite line numbers:
\begin{pycode}
with open("fracexample.cpp", "r") as f:
  didactic_mint(f.read(), lang="cpp", hlgrep=["^#line"])
\end{pycode}

If we look at the file [[cppjava.nw]] (the source file for this section), we 
can see this around line 36:
\inputminted[firstline=32,lastline=40]{text}{cppjava.nw}
That is, the contents of
[[<<fracexample.cpp>>]]
starts at line 36.

Let's introduce the file [[<<fracexample2.cpp>>]] and introduce an error in it.
It should have the same contents as [[<<fracexample.cpp>>]], but we also add an 
erroneous function definition.
We intentionally spell [[int]] as [[inte]] to trigger a compilation error.
<<fracexample2.cpp>>=
<<fracexample.cpp>>

inte bad_return_type_func() {
  return 0;
}
@

Let's have a look at the tangled file [[<<fracexample2.cpp>>]].
\inputminted[highlightlines={1,12}]{cpp}{fracexample2.cpp}
We note lines 1 and 12.
Line 1 maps to the same line in the original \noweb{} source, just the same as 
above.
But line 12 maps to line 177 in the original \noweb{} source.
That's because we introduced [[<<fracexample2.cpp>>]] that far down:
\inputminted[firstline=173,lastline=180]{text}{cppjava.nw}

Let's try to compile [[<<fracexample2.cpp>>]] and have a look at the error 
message from the compiler.
We'll compile with
\begin{minted}[numbers=none]{bash}
g++ -g -std=c++17 -Wall -Wextra -Werror -o fracexample2 \
  fracexample2.cpp fraction.cpp
\end{minted}
The result is the following:
\begin{pycode}
didactic_shell("g++ -std=c++17 -Wall -Wextra -Werror -o fracexample2 "
               "fracexample2.cpp fraction.cpp "
               "2>&1",
               shell=True, minted_opts="numbers=none")
\end{pycode}
Indeed, we note that the compiler's error refers to the file [[cppjava.nw]] on 
line 177, rather than the tangled file [[fracexample2.cpp]].
Now, we'll get the same when debugging using [[gdb]], it will refer to the 
literate source instead of the tangled file.
(I've hightlighted some lines to make it easier to read the following output.)
\begin{minted}[highlightlines={18,41,43,48}]{text}
$ gdb ./fracexample
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./fracexample...
(gdb) l 35
warning: Source file is more recent than executable.
30      @
31
32      \subsection{C++}
33
34      The class should be used as the following example programs show.
35      @<<fracexample.cpp>>=
36      #include <iostream>
37      #include "fraction.h"
38
39      int main() {
(gdb) l
40        Fraction f1(1, 2);
41        Fraction f2(1, 3);
42        std::cout @<< f1 @<< " + " @<< f2
43                  @<< " = " @<< (f1 + f2) @<< std::endl;
44      }
45      @
46
47      The expected output is:
48      \begin{pycode}
49      didactic_shell("./fracexample", minted_opts="numbers=none")
(gdb) b 42
Breakpoint 1 at 0x2411: file /home/dbosk/devel/edu/literate-programming/whatis/cppjava.nw, line 42.
(gdb) r
Starting program: /home/dbosk/devel/edu/literate-programming/whatis/fracexample 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at /home/dbosk/devel/edu/literate-programming/whatis/cppjava.w:42
42        std::cout @<< f1 @<< " + " @<< f2
(gdb) 
\end{minted}
We see above that the breakpoint refers to lines in the literate source.
And, indeed, when we ask [[gdb]] to list the source around the breakpoint, it 
lists the literate source.
(We used [[gdb]] in the example, this is what IDEs like VSCode do as well, so 
it will work there too.)

\begin{activity}
Tangle the files with and without the [[-L]] flag and compile them.
See how it affects compiler messages and the debugger.
\end{activity}

We also want to see that this works also for the tests.
We're going to add a test for a case that we intensionally \emph{don't} handle, 
namely having a zero denominator.
We would expect setting the denominator to zero to throw an exception.
<<tests for Fraction>>=
TEST(Fraction, ZeroDenominator) {
  EXPECT_THROW(Fraction f(1, 0), std::invalid_argument);
}
<<headers to include>>=
#include <stdexcept>
@

When we execute the tests, we'll get the following output:
\begin{pycode}
didactic_shell("./fractest",
               hlgrep=["cppjava.nw"],
               minted_opts="numbers=none")
\end{pycode}
Let's have a peek at the lines around line 279 in [[cppjava.nw]]:
\inputminted[firstline=273,lastline=283]{text}{cppjava.nw}


\subsubsection{The class}

The class [[Fraction]] should represent a fraction.
The class needs two private attributes, [[numerator]] and [[denominator]] to 
keep track of those values.
We saw above that the class should have a constructor that takes two integers 
and initializes the attributes.
We also want to overload the operator [[+]] to add two fractions.
Finally, we also want to print a fraction in the form 
[[numerator/denominator]]---shortened as much as possible.
This gives us the following header file:
<<fraction.h>>=
<<headers to include>>

class Fraction {
  private:
    int numerator;
    int denominator;
  public:
    Fraction(int numerator, int denominator);

    <<methods for Fraction>>
    <<overloaded operators>>
};
@

\subsubsection{Implementing the methods}

Now we need to implement the methods, we have [[to_string]] and
[[<<overloaded operators>>]] to implement.
That should be done in the file [[<<fraction.cpp>>]].
<<fraction.cpp>>=
<<headers to include>>
#include "fraction.h"

<<implementation of methods for Fraction>>
<<implementation of overloaded operators>>
@

To compile this file, we need the following simple rule.
<<frac targets>>=
fraction.o: fraction.cpp fraction.h
<<remove generated files>>=
rm -f fraction.o
@

\subsubsection{The constructor}

The constructor should initialize the attributes.
We'll also want it to shorten the fraction as much as possible.
But we'll return to that later.
<<implementation of methods for Fraction>>=
Fraction::Fraction(int numerator, int denominator)
  : numerator(numerator), denominator(denominator)
{
  <<shorten [[numerator]] and [[denominator]]>>
}
@

Let's test this:
<<tests for Fraction>>=
TEST(Fraction, Constructor) {
  Fraction f2(2, 4);
  EXPECT_EQ(f2.to_string(), "1/2");
}
@

\subsubsection{Shortening the fraction}

To shorten the fraction, we need to find the greatest common divisor of the 
numerator and the denominator.
We can then divide both by this number.

We can use the [[std::gcd]] function from the C++17 standard library.
It requires the header [[<numeric>]].
<<headers to include>>=
#include <numeric>
<<shorten [[numerator]] and [[denominator]]>>=
int gcd = std::gcd(numerator, denominator);
this->numerator /= gcd;
this->denominator /= gcd;
@

Let's test this:
<<tests for Fraction>>=
TEST(Fraction, AddShorten) {
  Fraction f7(2, 4);
  EXPECT_EQ(f7.to_string(), "1/2");
  Fraction f8(1, 2);
  Fraction f9 = f7 + f8;
  EXPECT_EQ(f9.to_string(), "1/1");
}
@

\subsubsection{Converting to string}

We want to be able to print a fraction.
We can do this by implementing a method [[to_string]].
<<methods for Fraction>>=
std::string to_string() const;
<<implementation of methods for Fraction>>=
std::string Fraction::to_string() const {
  return std::to_string(numerator) + "/" + std::to_string(denominator);
}
<<headers to include>>=
#include <string>
@

Let's test this method.
We'll test two things:
\begin{enumerate}
\item That the fraction is printed correctly.
\item That the fraction is shortened.
\end{enumerate}
<<tests for Fraction>>=
TEST(Fraction, ToString) {
  Fraction f(1, 2);
  EXPECT_EQ(f.to_string(), "1/2");
  Fraction f2(4, 2);
  EXPECT_EQ(f2.to_string(), "2/1");
}
@

Now we also want to use this one to overload the [[<<]] operator so that we can 
print fractions using [[std::cout]].
Note that we don't define it as part of the class, in
[[<<overloaded operators>>]], but only outside the class.
This is to be able to do the overloading and controlling both parameters.
As part of the class it implicitly gets the [[this]] parameter instead.
<<headers to include>>=
#include <iostream>
<<overloaded operators>>=
friend std::ostream& operator<<(std::ostream& os, const Fraction& f);
<<implementation of overloaded operators>>=
std::ostream& operator<<(std::ostream& os, const Fraction& f) {
  os << f.to_string();
  return os;
}
@


\subsubsection{Adding fractions}

Let's turn to the overloaded [[+]] operator.
Let's start with some tests to see what we want to achieve.
<<tests for Fraction>>=
TEST(Fraction, Add) {
  Fraction f1(1, 2);
  Fraction f2(1, 3);
  Fraction f3 = f1 + f2;
  EXPECT_EQ(f3.to_string(), "5/6");

  Fraction f4(1, 3);
  Fraction f5(1, 3);
  Fraction f6 = f4 + f5;
  EXPECT_EQ(f6.to_string(), "2/3");
}
@

To achieve this, we need the method named [[operator+]].
<<overloaded operators>>=
Fraction operator+(const Fraction& other) const;
@ We'll use a reference for [[other]], but make it [[const]] so that we can't 
change it.
We also add [[const]] to the method itself to indicate that it doesn't change 
the object ([[this]]).
<<implementation of overloaded operators>>=
Fraction Fraction::operator+(const Fraction& other) const {
  <<add [[this]] and [[other]] into [[new_numerator]] and [[new_denominator]]>>
  return Fraction(new_numerator, new_denominator);
}
@ We don't need to do anything special to shorten the fraction here.
Because the constructor already does that when we create the new [[Fraction]] 
that is returned.

To add two fractions, we need to find a common denominator.
We can then just add the numerators.
<<add [[this]] and [[other]] into [[new_numerator]] and [[new_denominator]]>>=
int new_numerator = numerator * other.denominator
                    + other.numerator * denominator;
int new_denominator = denominator * other.denominator;
@


\subsection{Java}

The class should have two fields, \texttt{numerator} and \texttt{denominator}, 
and a constructor that takes two integers and initializes the fields.

The class should also have a method \texttt{add} (as Java doesn't support 
operator overloading) that takes another fraction as an argument and returns a 
new fraction that is the sum of the two fractions.

Finally, the class should have a method \texttt{toString} that returns a string 
representation of the fraction in the form 
\texttt{numerator/denominator}---shortened as much as possible.

\begin{activity}
Based on the ideas from the C++ part, write the corresponding Java program.
\end{activity}

\begin{activity}
Java doesn't support the line preprocessor directive as the C++ compiler and 
debugger do.
Consequently, we can't use the exact same approach as for C++.
Can we solve this in another, yet similar, way?
\end{activity}

\subsection{The \noweb{} source}

Let's have a look at the \noweb{} source file for this section, \cref{cppjava}.
\inputminted{text}{cppjava.nw}
