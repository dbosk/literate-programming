\mode*
\label{cppjava}

We want to write a short class to work with fractions.
We want to do this twice, once for C++ and once for Java.

\begin{activity}
While reading the rest of this section,
try to write the same program and experiment with it.
\end{activity}

\subsection{C++}

The class should be used as the following example programs show.
<<fracexample.cpp>>=
#include <iostream>
#include "fraction.h"

int main() {
  Fraction f1(1, 2);
  Fraction f2(1, 3);
  std::cout << f1 << " + " << f2
            << " = " << (f1 + f2) << std::endl;
}
@

The expected output is:
\begin{pycode}
didactic_shell("./fracexample", minted_opts="numbers=none")
\end{pycode}

We also want to test the fraction class with the following test program.
The test program will use Google Test framework.
<<fractest.cpp>>=
#include <gtest/gtest.h>
#include "fraction.h"

<<tests for Fraction>>

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
@

We should write a class [[Fraction]] that represents a fraction.
The class should have two attributes, [[numerator]] and [[denominator]].
The class should have a constructor that takes two integers and initializes the 
attributes.
We also want to overload the operator [[+]] to add two fractions.

Finally, we also want to print a fraction in the form 
[[numerator/denominator]]---shortened as much as possible.

We'll need two files: [[<<fraction.h>>]] and [[<<fraction.cpp>>]].
This gives us the following header file:
<<fraction.h>>=
<<headers to include>>

class Fraction {
  private:
    int numerator;
    int denominator;
  public:
    Fraction(int numerator, int denominator);

    <<methods for Fraction>>
    <<overloaded operators>>
};
@

\subsubsection{Compiling the files}

We'll construct [[cppfrac.mk]] to include in our [[Makefile]] to cover how we 
compile these.

We can start with the flags for the compiler and linker.
We'll use the Google Test framework, so we need to link against that.
We also need C++17.
And then we also want the usual [[-W]] flags to catch common errors.
<<cppfrac.mk>>=
CXXFLAGS+=  -std=c++17 -Wall -Wextra -Werror ${DEBUGFLAGS}
LDFLAGS+=   -lstdc++
@

Now, let's turn to the rules of the files to compile.
<<cppfrac.mk>>=
.PHONY: all
all: fractest fracexample

fraction.o: fraction.cpp fraction.h
fracexample: fraction.o fracexample.cpp fraction.h
@

Now, [[fractest]] is a special case.
Here we need to link against the Google Test framework.
So we need a custom build rule for this that includes [[-lgtest]] and 
[[lgtest_main]] so that the linker links against the Google Test framework.
<<cppfrac.mk>>=
fractest: fraction.o fractest.cpp fraction.h
	${CXX} ${CXXFLAGS} -o $@ $^ ${LDFLAGS} -lgtest -lgtest_main
@

\subsubsection{Tangling with the \texttt{-L} flag}

These targets above depend on the source files.
We need to build them from the \noweb{} source file.
<<cppfrac.mk>>=
fraction.cpp fraction.h fractest.cpp fracexample.cpp: cppjava.nw
	notangle -L -R$@ $< | cpif $@
@ When we tangle the files, we want the [[-L]].
The [[-L]] flag will rewrite the line numbers so that the compiler error 
messages will refer to the correct line in the \noweb{} source file, instead of 
the tangled file.
Without the [[-L]] flag, the tangled source will look as expected:
\begin{pycode}
didactic_shell("notangle -Rfracexample.cpp cppjava.nw",
               shell=True, lang="cpp")
\end{pycode}
But if we use the [[-L]] flag, the tangled source will include the directives 
to rewrite line numbers:
\begin{pycode}
with open("fracexample.cpp", "r") as f:
  didactic_mint(f.read(), lang="cpp", hlgrep=["^#line"])
\end{pycode}

If we look at the file [[cppjava.nw]] (the source file for this section), we 
can see this around line 11:
\inputminted[firstline=7,lastline=15]{text}{cppjava.nw}
That is, the contents of
[[<<fracexample.cpp>>]]
starts at line 11.

Let's introduce the file [[<<fracexample2.cpp>>]] and introduce an error in it.
It should have the same contents as [[<<fracexample.cpp>>]], but we also add an 
erroneous function definition.
We intentionally spell [[int]] as [[inte]] to trigger a compilation error.
<<fracexample2.cpp>>=
<<fracexample.cpp>>

inte bad_return_type_func() {
  return 0;
}
@

Let's have a look at the tangled file [[<<fracexample2.cpp>>]].
\inputminted[highlightlines={1,12}]{cpp}{fracexample2.cpp}
We note lines 1 and 12.
Line 1 maps to the same line in the original \noweb{} source, just the same as 
above.
But line 12 maps to line 136 in the original \noweb{} source.
That's because we introduced [[<<fracexample2.cpp>>]] that far down:
\inputminted[firstline=132,lastline=139]{text}{cppjava.nw}

Let's try to compile [[<<fracexample2.cpp>>]] and have a look at the error 
message from the compiler.
We'll compile with
\begin{minted}[numbers=none]{bash}
g++ -std=c++17 -Wall -Wextra -Werror -o fracexample2 \
  fracexample2.cpp fraction.cpp
\end{minted}
The result is the following:
\begin{pycode}
didactic_shell("g++ -std=c++17 -Wall -Wextra -Werror -o fracexample2 "
               "fracexample2.cpp fraction.cpp "
               "2>&1",
               shell=True, minted_opts="numbers=none")
\end{pycode}
Indeed, we note that the compiler's error refers to the file [[cppjava.nw]] on 
line 136, rather than the tangled file [[fracexample2.cpp]].
Now, we'll get the same when debugging using [[gdb]], it will refer to the 
literate source instead of the tangled file.
\begin{minted}[highlightlines={18,21,29,40,43-44},numbers=none]{text}
$ gdb fracexample
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from fracexample...
(gdb) b 17
Breakpoint 1 at 0x2411: file /home/dbosk/devel/edu/literate-programming/whatis/cppj
ava.nw, line 17.
(gdb) r
Starting program: /home/dbosk/devel/edu/literate-programming/whatis/fracexample 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at /home/dbosk/devel/edu/literate-programming/whatis/cppjava.
nw:17
17        std::cout @<< f1 @<< " + " @<< f2
(gdb) l 10
5       We want to do this twice, once for C++ and once for Java.
6
7       \subsection{C++}
8
9       The class should be used as the following example programs show.
10      @<<fracexample.cpp>>=
11      #include <iostream>
12      #include "fraction.h"
13
14      int main() {
(gdb) l
15        Fraction f1(1, 2);
16        Fraction f2(1, 3);
17        std::cout @<< f1 @<< " + " @<< f2
18                  @<< " = " @<< (f1 + f2) @<< std::endl;
19      }
20      @
21
22      The expected output is:
23      \begin{pycode}
24      didactic_shell("./fracexample", minted_opts="numbers=none")
(gdb)
\end{minted}
We see above that the breakpoint refers to lines in the literate source.
And, indeed, when we ask [[gdb]] to list the source around the breakpoint, it 
lists the literate source.

\begin{activity}
Tangle the files with and without the [[-L]] flag and compile them.
See how it affects compiler messages and the debugger.
\end{activity}

\subsubsection{Cleaning up}

Finally, we need to clean up.
We want to remove the object file and the executables.
We also want to remove the generated source files.
<<cppfrac.mk>>=
.PHONY: clean clean-cppfrac
clean: clean-cppfrac
clean-cppfrac:
	rm -f fraction.o fractest fracexample
	rm -f fraction.cpp fraction.h fractest.cpp fracexample.cpp
@

\subsubsection{Implementing the methods}

Now we need to implement the methods, we have [[to_string]] and
[[<<overloaded operators>>]] to implement.
That should be done in the file [[<<fraction.cpp>>]].
<<fraction.cpp>>=
<<headers to include>>
#include "fraction.h"

<<implementation of methods for Fraction>>
<<implementation of overloaded operators>>
@

\subsubsection{Constructor}

The constructor should initialize the attributes.
We'll also want it to shorten the fraction as much as possible.
But we'll return to that later.
<<implementation of methods for Fraction>>=
Fraction::Fraction(int numerator, int denominator)
  : numerator(numerator), denominator(denominator)
{
  <<shorten [[numerator]] and [[denominator]]>>
}
@

Let's test this:
<<tests for Fraction>>=
TEST(Fraction, Constructor) {
  Fraction f2(2, 4);
  EXPECT_EQ(f2.to_string(), "1/2");
}
@

\subsubsection{Converting to string}

We want to be able to print a fraction.
We can do this by implementing a method [[to_string]].
<<methods for Fraction>>=
std::string to_string() const;
<<implementation of methods for Fraction>>=
std::string Fraction::to_string() const {
  return std::to_string(numerator) + "/" + std::to_string(denominator);
}
<<headers to include>>=
#include <string>
@

Let's test this method.
We'll test two things:
\begin{enumerate}
\item That the fraction is printed correctly.
\item That the fraction is shortened.
\end{enumerate}
<<tests for Fraction>>=
TEST(Fraction, ToString) {
  Fraction f(1, 2);
  EXPECT_EQ(f.to_string(), "1/2");
  Fraction f2(4, 2);
  EXPECT_EQ(f2.to_string(), "2/1");
}
@

Now we also want to use this one to overload the [[<<]] operator so that we can 
print fractions using [[std::cout]].
Note that we don't define it as part of the class, in
[[<<overloaded operators>>]], but only outside the class.
This is to be able to do the overloading and controlling both parameters.
As part of the class it implicitly gets the [[this]] parameter instead.
<<headers to include>>=
#include <iostream>
<<overloaded operators>>=
friend std::ostream& operator<<(std::ostream& os, const Fraction& f);
<<implementation of overloaded operators>>=
std::ostream& operator<<(std::ostream& os, const Fraction& f) {
  os << f.to_string();
  return os;
}
@


\subsubsection{Adding fractions}

Let's turn to the overloaded [[+]] operator.
Let's start with some tests to see what we want to achieve.
<<tests for Fraction>>=
TEST(Fraction, Add) {
  Fraction f1(1, 2);
  Fraction f2(1, 3);
  Fraction f3 = f1 + f2;
  EXPECT_EQ(f3.to_string(), "5/6");

  Fraction f4(1, 3);
  Fraction f5(1, 3);
  Fraction f6 = f4 + f5;
  EXPECT_EQ(f6.to_string(), "2/3");
}
@

To achieve this, we need the method named [[operator+]].
<<overloaded operators>>=
Fraction operator+(const Fraction& other) const;
@ We'll use a reference for [[other]], but make it [[const]] so that we can't 
change it.
We also add [[const]] to the method itself to indicate that it doesn't change 
the object ([[this]]).
<<implementation of overloaded operators>>=
Fraction Fraction::operator+(const Fraction& other) const {
  <<add [[this]] and [[other]] into [[new_numerator]] and [[new_denominator]]>>
  return Fraction(new_numerator, new_denominator);
}
@ We don't need to do anything special to shorten the fraction here.
Because the constructor already does that when we create the new [[Fraction]] 
that is returned.

To add two fractions, we need to find a common denominator.
We can then just add the numerators.
<<add [[this]] and [[other]] into [[new_numerator]] and [[new_denominator]]>>=
int new_numerator = numerator * other.denominator
                    + other.numerator * denominator;
int new_denominator = denominator * other.denominator;
@

\subsubsection{Shortening the fraction}

To shorten the fraction, we need to find the greatest common divisor of the 
numerator and the denominator.
We can then divide both by this number.

We can use the [[std::gcd]] function from the C++17 standard library.
It requires the header [[<numeric>]].
<<headers to include>>=
#include <numeric>
<<shorten [[numerator]] and [[denominator]]>>=
int gcd = std::gcd(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
@

Let's test this:
<<tests for Fraction>>=
TEST(Fraction, AddShorten) {
  Fraction f7(1, 2);
  Fraction f8(1, 2);
  Fraction f9 = f7 + f8;
  EXPECT_EQ(f9.to_string(), "1/1");
}
@


\subsection{Java}

The class should have two fields, \texttt{numerator} and \texttt{denominator}, 
and a constructor that takes two integers and initializes the fields.

The class should also have a method \texttt{add} that takes another fraction as an argument and returns a new fraction that is the sum of the two fractions.

Finally, the class should have a method \texttt{toString} that returns a string 
representation of the fraction in the form 
\texttt{numerator/denominator}---shortened as much as possible.


\subsection{The \noweb{} source}

Let's have a look at the \noweb{} source file for this section, \cref{cppjava}.
\inputminted{text}{cppjava.nw}
